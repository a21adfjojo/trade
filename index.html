<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>架空株式市場</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
      body {
        font-family: sans-serif;
        background: #121212;
        color: #eee;
        margin: 0;
        padding: 0;
      }
      h2,
      h4 {
        margin: 5px 0;
      }
      #controls {
        padding: 10px;
        background: #222;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
        align-items: center;
      }
      #balance,
      #portfolio {
        font-weight: bold;
      }
      canvas {
        display: block;
        background: #111;
        margin: 10px auto;
        max-width: 95%;
      }
      .section {
        padding: 5px;
        margin: 5px;
        background: #222;
      }
      #orderBook div {
        display: flex;
        justify-content: space-between;
      }
      label {
        display: block;
        font-size: 0.8em;
        color: #aaa;
      }
      input,
      select,
      button {
        width: 100%;
        padding: 4px;
        border: none;
        border-radius: 3px;
      }
      button {
        background: #0a0;
        color: #fff;
        cursor: pointer;
      }

      /* Responsive adjustments for smaller screens */
      @media (max-width: 768px) {
        #controls {
          grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        }
      }
      @media (max-width: 480px) {
        #controls {
          grid-template-columns: 1fr; /* Stack items vertically on very small screens */
        }
      }
    </style>
  </head>
  <body>
    <h2>架空株式市場</h2>

    <div id="controls">
      <div>
        <label>残高</label>
        <span id="balance">-</span>
      </div>
      <div>
        <label>銘柄選択</label>
        <select id="symbolSelect"></select>
      </div>
      <div>
        <label>売買</label>
        <select id="sideSelect">
          <option value="buy">買い</option>
          <option value="sell">売り</option>
        </select>
      </div>
      <div>
        <label>注文タイプ</label>
        <select id="typeSelect">
          <option value="limit">指値</option>
          <option value="market">成行</option>
          <option value="stop">逆指値</option>
        </select>
      </div>
      <div>
        <label>価格（指値/逆指値）</label>
        <input id="priceInput" type="number" placeholder="Price" />
      </div>
      <div>
        <label>逆指値価格（Stop）</label>
        <input id="stopInput" type="number" placeholder="StopPrice" />
      </div>
      <div>
        <label>株数</label>
        <input id="amountInput" type="number" value="1" min="1" />
      </div>
      <div>
        <label>&nbsp;</label>
        <button id="placeBtn">注文</button>
      </div>
      <div>
        <label>保有株</label>
        <div id="portfolio"></div>
      </div>
    </div>

    <div class="section" id="orderBook">
      <h4>Order Book (<span id="currentSymbolName"></span>)</h4>
      <div id="buyOrders"></div>
      <div id="sellOrders"></div>
    </div>

    <div class="section" id="tradeHistory">
      <h4>Trade History</h4>
    </div>

    <canvas id="priceChart" height="200"></canvas>

    <script>
      const socket = io();
      let currentUser = { balance: 0, holdings: {}, learningMode: true };
      let companies = [],
        priceHistory = {},
        chart = null;
      const MAX_CHART_HISTORY = 50; // Maximum data points for the chart

      // Function to generate distinct HSL colors
      function getRandomColor(index, total) {
        const hue = (index * 137 + 100) % 360; // Use golden angle approximation for even distribution
        return `hsl(${hue}, 70%, 50%)`;
      }

      // ページロード時に注文フォームの表示を更新
      document.addEventListener("DOMContentLoaded", () => {
        const typeSelect = document.getElementById("typeSelect");
        const priceInput = document.getElementById("priceInput");
        const stopInput = document.getElementById("stopInput");

        function updateOrderFormVisibility() {
          const selectedType = typeSelect.value;
          if (selectedType === "market") {
            priceInput.disabled = true;
            priceInput.value = ""; // 成行の場合は価格入力をクリア
            stopInput.disabled = true;
            stopInput.value = ""; // ストップ価格入力をクリア
          } else if (selectedType === "limit") {
            priceInput.disabled = false;
            stopInput.disabled = true;
            stopInput.value = "";
          } else if (selectedType === "stop") {
            priceInput.disabled = false; // 逆指値の場合も指値価格を入力させる
            stopInput.disabled = false;
          }
        }

        typeSelect.addEventListener("change", updateOrderFormVisibility);
        // 初期ロード時にも適用
        updateOrderFormVisibility();
      });

      socket.on("userData", (data) => {
        currentUser = data;
        document.getElementById("balance").textContent =
          data.balance.toFixed(2);
        updatePortfolio();
      });

      socket.on("state", (payload) => {
        companies = payload.companies;
        const sel = document.getElementById("symbolSelect");

        // Update symbol dropdown if it's empty or companies have changed
        if (
          sel.options.length === 0 ||
          sel.options.length !== companies.length
        ) {
          sel.innerHTML = ""; // Clear existing options
          companies.forEach((c) => sel.add(new Option(c.symbol, c.symbol)));
          // Set a default selected symbol if none is selected
          if (sel.value === "" && companies.length > 0) {
            sel.value = companies[0].symbol;
          }
        }

        // Update price history for ALL companies
        companies.forEach((c) => {
          if (!priceHistory[c.symbol]) priceHistory[c.symbol] = [];
          priceHistory[c.symbol].push(c.price);
          if (priceHistory[c.symbol].length > MAX_CHART_HISTORY) {
            priceHistory[c.symbol].shift();
          }
        });

        // Update chart for all companies
        updateAllCompanyCharts();
        // Update order book for the currently selected company
        updateOrderBook();
      });

      socket.on("trade", (t) => {
        const hist = document.getElementById("tradeHistory");
        const tradeEntry = document.createElement("div");
        tradeEntry.textContent = `${t.symbol} ${t.amount}株 @ ${t.price.toFixed(
          2
        )}`;
        hist.prepend(tradeEntry); // 新しい取引を一番上に追加
        // 履歴が長くなりすぎたら古いものを削除
        if (hist.children.length > 20) {
          hist.removeChild(hist.lastChild);
        }
      });

      document.getElementById("placeBtn").addEventListener("click", () => {
        const symbol = document.getElementById("symbolSelect").value;
        const side = document.getElementById("sideSelect").value;
        const type = document.getElementById("typeSelect").value;
        let price = null;
        let stopPrice = null;

        if (type !== "market") {
          price = Number(document.getElementById("priceInput").value);
          if (isNaN(price) || price <= 0) {
            alert("有効な価格を入力してください。");
            return;
          }
        }
        if (type === "stop") {
          stopPrice = Number(document.getElementById("stopInput").value);
          if (isNaN(stopPrice) || stopPrice <= 0) {
            alert("有効な逆指値価格を入力してください。");
            return;
          }
        }

        const amount = Number(document.getElementById("amountInput").value);
        if (isNaN(amount) || amount <= 0) {
          alert("有効な株数を入力してください。");
          return;
        }

        socket.emit("placeOrder", {
          symbol,
          side,
          price,
          amount,
          type,
          stopPrice,
        });
      });

      // 銘柄選択が変更されたときに板情報とチャートを更新
      document.getElementById("symbolSelect").addEventListener("change", () => {
        updateOrderBook();
        // The main chart now shows all companies, so no need to re-render it here based on selection.
        // updateAllCompanyCharts(); // Only if you want to highlight the selected symbol or something specific.
      });

      function updatePortfolio() {
        const div = document.getElementById("portfolio");
        let html = "";
        for (const sym in currentUser.holdings) {
          if (currentUser.holdings[sym] > 0) {
            // 保有株数が0より大きい場合のみ表示
            html += `${sym}: ${currentUser.holdings[sym]}株<br>`;
          }
        }
        div.innerHTML = html || "保有株なし"; // 保有株がない場合の表示
      }

      function updateOrderBook() {
        const selectedSymbol = document.getElementById("symbolSelect").value;
        const company = companies.find((c) => c.symbol === selectedSymbol);

        document.getElementById("currentSymbolName").textContent =
          selectedSymbol;

        if (!company) {
          document.getElementById("buyOrders").innerHTML =
            "<b>買い板</b><br>選択された銘柄のデータがありません";
          document.getElementById("sellOrders").innerHTML =
            "<b>売り板</b><br>選択された銘柄のデータがありません";
          return;
        }

        // サーバーから送られてくる orderBook は既にソートされていると仮定
        document.getElementById("buyOrders").innerHTML =
          "<b>買い板</b><br>" +
          (company.orderBook.buy || [])
            .map(
              (o) =>
                `${o.price.toFixed(2)} : ${o.amount}${
                  o.type === "stop" && o.stopPrice !== null
                    ? " (Stop:" + o.stopPrice.toFixed(2) + ")"
                    : ""
                }`
            )
            .join("<br>");
        document.getElementById("sellOrders").innerHTML =
          "<b>売り板</b><br>" +
          (company.orderBook.sell || [])
            .map(
              (o) =>
                `${o.price.toFixed(2)} : ${o.amount}${
                  o.type === "stop" && o.stopPrice !== null
                    ? " (Stop:" + o.stopPrice.toFixed(2) + ")"
                    : ""
                }`
            )
            .join("<br>");
      }

      function updateAllCompanyCharts() {
        const ctx = document.getElementById("priceChart").getContext("2d");

        const datasets = companies.map((c, index) => {
          const data = priceHistory[c.symbol] || [];
          const color = getRandomColor(index, companies.length);
          return {
            label: c.symbol,
            data: data,
            borderColor: color,
            backgroundColor: "transparent",
            tension: 0.2,
            pointRadius: 0, // Hide points for cleaner lines
          };
        });

        // Generate labels based on the longest history, up to MAX_CHART_HISTORY
        const maxHistoryLength = Math.max(
          ...Object.values(priceHistory).map((arr) => arr.length),
          0
        );
        const labels = Array.from(
          { length: maxHistoryLength },
          (_, i) => i + 1
        );

        if (!chart) {
          chart = new Chart(ctx, {
            type: "line",
            data: { labels, datasets },
            options: {
              responsive: true,
              maintainAspectRatio: false, // Allow canvas to resize freely
              animation: false,
              plugins: {
                legend: {
                  position: "top",
                  labels: {
                    color: "#eee", // Legend text color
                  },
                },
                tooltip: {
                  mode: "index",
                  intersect: false,
                },
              },
              scales: {
                x: {
                  display: false, // Hide x-axis labels for a cleaner look
                  grid: {
                    color: "rgba(255, 255, 255, 0.1)",
                  },
                },
                y: {
                  beginAtZero: false,
                  grid: {
                    color: "rgba(255, 255, 255, 0.1)",
                  },
                  ticks: {
                    color: "#eee", // Y-axis tick labels color
                  },
                },
              },
            },
          });
        } else {
          chart.data.datasets = datasets;
          chart.data.labels = labels;
          chart.update();
        }
      }
    </script>
  </body>
</html>
